#!/bin/bash
# Eden doctor - Health check and validation
set -e

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

ERRORS=0

check_pass() {
    echo -e "  ${GREEN}✓${NC} $1"
}

check_fail() {
    echo -e "  ${RED}✗${NC} $1"
    ((ERRORS++))
}

check_warn() {
    echo -e "  ${YELLOW}⚠${NC} $1"
}

section() {
    echo ""
    echo "$1"
}

# Get Eden directory (parent of bin/)
EDEN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

section "Eden Health Check"
section "=================="

# Check dependencies
section "Dependencies:"

if command -v git >/dev/null 2>&1; then
    GIT_VER=$(git --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    check_pass "git installed ($GIT_VER)"
else
    check_fail "git not found"
fi

if command -v stow >/dev/null 2>&1; then
    STOW_VER=$(stow --version | head -1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
    if awk -v ver="$STOW_VER" 'BEGIN { exit (ver < 2.3) }'; then
        check_pass "stow installed ($STOW_VER)"
    else
        check_warn "stow $STOW_VER (recommend >= 2.3.0)"
    fi
else
    check_fail "stow not found"
fi

# Check repository
section "Repository:"

cd "$EDEN_DIR" || check_fail "Cannot access Eden directory"

if [ -d "$EDEN_DIR/.git" ]; then
    check_pass "Eden git repository exists"
    
    if git diff-index --quiet HEAD -- 2>/dev/null; then
        check_pass "Repository is clean (no uncommitted changes)"
    else
        check_warn "Repository has uncommitted changes"
    fi
else
    check_fail "Not a git repository"
fi

# Check Eden directories and binaries
section "Eden Structure:"

# Check smart wrapper
if [ -f "$HOME/.local/bin/eden" ] && [ ! -L "$HOME/.local/bin/eden" ]; then
    check_pass "Eden wrapper installed at ~/.local/bin/eden"
else
    if [ -L "$HOME/.local/bin/eden" ]; then
        check_warn "Eden wrapper is a symlink (should be copied file)"
    else
        check_fail "Eden wrapper not found at ~/.local/bin/eden"
    fi
fi

# Check main implementation
if [ -f "$EDEN_DIR/bin/eden" ]; then
    check_pass "Eden CLI implementation at bin/eden"
else
    check_fail "Eden CLI missing at bin/eden"
fi

# Check ~/.eden structure
if [ -d "$HOME/.eden" ]; then
    check_pass "~/.eden directory exists"
    
    if [ -d "$HOME/.eden/libexec" ]; then
        LIBEXEC_COUNT=$(find "$HOME/.eden/libexec" -type f 2>/dev/null | wc -l)
        check_pass "~/.eden/libexec exists ($LIBEXEC_COUNT internal utilities)"
    else
        check_warn "~/.eden/libexec not found (may not be stowed yet)"
    fi
    
    if [ -d "$HOME/.eden/bin" ]; then
        BIN_COUNT=$(find "$HOME/.eden/bin" -type l 2>/dev/null | wc -l)
        check_pass "~/.eden/bin exists ($BIN_COUNT grafted binaries)"
    else
        check_warn "~/.eden/bin not found (no branch binaries grafted)"
    fi
    
    if [ -f "${XDG_CONFIG_HOME:-$HOME/.config}/eden/branches" ]; then
        check_pass "Branch tracking file exists"
    else
        check_warn "No branch tracking file (run 'eden graft' to set up)"
    fi
else
    check_warn "~/.eden directory not found (may not be stowed yet)"
fi

# Check symlinks
section "Symlinks:"

BROKEN=0
if command -v find >/dev/null 2>&1; then
    # Check for broken symlinks in common Eden locations
    for dir in "$HOME/.config" "$HOME/.local/bin"; do
        if [ -d "$dir" ]; then
            while IFS= read -r -d '' link; do
                if [ ! -e "$link" ]; then
                    check_warn "Broken symlink: $link"
                    ((BROKEN++))
                fi
            done < <(find "$dir" -maxdepth 2 -type l -print0 2>/dev/null)
        fi
    done
    
    if [ $BROKEN -eq 0 ]; then
        check_pass "No broken symlinks found"
    fi
else
    check_warn "find command not available, skipping symlink check"
fi

# Check macOS services (yabai, skhd)
if [ "$(uname -s)" = "Darwin" ]; then
    section "Services:"

    for svc in yabai skhd; do
        if command -v "$svc" >/dev/null 2>&1; then
            if pgrep -x "$svc" >/dev/null 2>&1; then
                check_pass "$svc running"
            else
                check_warn "$svc installed but not running ($svc --start-service)"
            fi
        fi
    done

    if [ -d "/Applications/Karabiner-Elements.app" ]; then
        if pgrep -f "karabiner_" >/dev/null 2>&1; then
            check_pass "Karabiner running"
        else
            check_warn "Karabiner installed but not running"
        fi
    fi
fi

# Check package counts
section "Package Statistics:"

COMMON_COUNT=$(find "$EDEN_DIR/packages/common" -type f 2>/dev/null | wc -l)
EDEN_COUNT=$(find "$EDEN_DIR/packages/eden" -type f 2>/dev/null | wc -l)
ARCH_COUNT=$(find "$EDEN_DIR/packages/arch" -type f 2>/dev/null | wc -l)
MAC_COUNT=$(find "$EDEN_DIR/packages/mac" -type f 2>/dev/null | wc -l)

echo "  Files: $COMMON_COUNT in common, $EDEN_COUNT in eden, $ARCH_COUNT in arch, $MAC_COUNT in mac"

# Platform parity check
section "Platform Parity:"

# Check for duplicate paths between common and platform packages
OS=""
case "$(uname -s)" in
    Linux*) OS="arch" ;;
    Darwin*) OS="mac" ;;
esac

if [ -n "$OS" ]; then
    DUPLICATES=0
    while IFS= read -r file; do
        REL_PATH="${file#$EDEN_DIR/packages/common/}"
        if [ -f "$EDEN_DIR/packages/$OS/$REL_PATH" ]; then
            check_warn "Duplicate: $REL_PATH (in both common and $OS)"
            ((DUPLICATES++))
        fi
    done < <(find "$EDEN_DIR/packages/common" -type f 2>/dev/null)
    
    if [ $DUPLICATES -eq 0 ]; then
        check_pass "No duplicate files between common and $OS packages"
    fi
fi

# Branch coverage - detect ungrafted configs
section "Branch Coverage:"

BRANCHES_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/eden/branches"

# Discover covered paths dynamically from grafters (each supports --covers)
GRAFTER_PATTERNS=()
GRAFTERS_DIR="$EDEN_DIR/packages/eden/.eden/libexec/grafters"
if [ -d "$GRAFTERS_DIR" ]; then
    for grafter in "$GRAFTERS_DIR"/graft-*; do
        [ -x "$grafter" ] || continue
        if ! grep -q -- '--covers' "$grafter" 2>/dev/null; then
            check_warn "$(basename "$grafter"): missing --covers support"
            continue
        fi
        while IFS= read -r pattern; do
            [ -n "$pattern" ] && GRAFTER_PATTERNS+=("$pattern")
        done < <("$grafter" --covers 2>/dev/null)
    done
fi

is_covered_by_grafter() {
    local path="$1"
    for pattern in "${GRAFTER_PATTERNS[@]}"; do
        # Match exact path or anything under the pattern directory
        if [[ "$path" == "$pattern" || "$path" == "$pattern/"* ]]; then
            return 0
        fi
    done
    return 1
}

is_metadata() {
    local path="$1"
    # Skip eden metadata and docs at branch root
    case "$path" in
        .eden-*|README.md|ARCHITECTURE.md) return 0 ;;
    esac
    return 1
}

if [ -f "$BRANCHES_FILE" ]; then
    while IFS= read -r branch_path; do
        [[ -z "$branch_path" ]] && continue
        [[ "$branch_path" =~ ^[[:space:]]*# ]] && continue

        # Expand variables
        branch_path="${branch_path//\$EDEN_ROOT/$EDEN_DIR}"
        branch_path="${branch_path/#\~/$HOME}"

        branch_name=$(basename "$branch_path")

        if [[ ! -d "$branch_path" ]]; then
            check_warn "$branch_name: branch directory not found"
            continue
        fi

        # Collect graft allowlist entries
        declare -a graft_entries=()
        GRAFT_FILE="$branch_path/.eden-graft"
        if [[ -f "$GRAFT_FILE" ]]; then
            while IFS= read -r entry; do
                [[ -z "$entry" ]] && continue
                [[ "$entry" =~ ^[[:space:]]*# ]] && continue
                entry=$(echo "$entry" | xargs)
                graft_entries+=("$entry")
            done < "$GRAFT_FILE"
        fi

        is_in_graft_list() {
            local path="$1"
            for entry in "${graft_entries[@]}"; do
                if [[ "$path" == "$entry" || "$path" == "$entry/"* ]]; then
                    return 0
                fi
                # Also check if a parent of path is listed
                if [[ "$entry" == "$path/"* ]]; then
                    return 0
                fi
            done
            return 1
        }

        # Find all top-level config paths in the branch
        orphans=()
        # Check .config/ subdirectories
        if [[ -d "$branch_path/.config" ]]; then
            for item in "$branch_path/.config"/*; do
                [[ -e "$item" ]] || continue
                item_name=$(basename "$item")
                rel_path=".config/$item_name"

                if is_covered_by_grafter "$rel_path"; then
                    continue
                fi

                # For files nested deeper (e.g. .config/pnpm/rc), check individual files
                if [[ -d "$item" ]]; then
                    # Check if the directory or any parent path is in graft list
                    if is_in_graft_list "$rel_path"; then
                        continue
                    fi
                    # Check individual files within
                    while IFS= read -r subfile; do
                        sub_rel="${subfile#$branch_path/}"
                        if ! is_in_graft_list "$sub_rel" && ! is_covered_by_grafter "$sub_rel"; then
                            orphans+=("$sub_rel")
                        fi
                    done < <(find "$item" -type f 2>/dev/null)
                else
                    if ! is_in_graft_list "$rel_path"; then
                        orphans+=("$rel_path")
                    fi
                fi
            done
        fi

        # Check root-level non-metadata files
        for item in "$branch_path"/*; do
            [[ -e "$item" ]] || continue
            item_name=$(basename "$item")
            if is_metadata "$item_name"; then
                continue
            fi
            if ! is_covered_by_grafter "$item_name" && ! is_in_graft_list "$item_name"; then
                orphans+=("$item_name")
            fi
        done

        if [ ${#orphans[@]} -eq 0 ]; then
            check_pass "$branch_name: all configs covered"
        else
            check_warn "$branch_name: ungrafted configs found:"
            for orphan in "${orphans[@]}"; do
                echo "      $orphan (not in .eden-graft, no dedicated grafter)"
            done
        fi

        unset graft_entries
    done < "$BRANCHES_FILE"
else
    echo "  No branches registered (skipping)"
fi

# Final result
section ""
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}✓ Eden is healthy!${NC}"
    exit 0
else
    echo -e "${RED}✗ Found $ERRORS issue(s)${NC}"
    exit 1
fi

