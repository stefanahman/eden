#!/bin/bash
# Eden Secrets Manager - List and validate 1Password requirements
set -e

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Use grafted secrets file (generated by 'eden graft')
SECRETS_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/eden/local/secrets-all"

# Check if grafted secrets file exists
if [[ ! -f "$SECRETS_FILE" ]]; then
    echo -e "${RED}✗${NC} Secrets registry not found: $SECRETS_FILE"
    echo ""
    echo "Run 'eden graft' to generate the secrets registry from all branches."
    echo ""
    exit 1
fi

# Single file mode - eden-secrets now reads only the grafted file
declare -a SECRETS_FILES
SECRETS_FILES+=("$SECRETS_FILE|All branches (grafted)")

show_help() {
    cat << EOF
Usage: eden-secrets <command>

Commands:
  list      List all required 1Password items
  validate  Check if required items exist in 1Password
  help      Show this help message

Examples:
  eden-secrets list       # Show what secrets Eden needs
  eden-secrets validate   # Check if they exist
EOF
}

list_secrets() {
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  Eden 1Password Requirements"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    # Process each secrets file (trunk + branches)
    for entry in "${SECRETS_FILES[@]}"; do
        IFS='|' read -r secrets_file source_name <<< "$entry"
        
        # Skip if file doesn't exist
        [[ ! -f "$secrets_file" ]] && continue
        
        # Parse secrets file (INI-style format)
        local in_secret=false
        local name="" path="" description="" required_by="" setup_command=""
        
        while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$line" ]] && continue
        
        # Check for [secret] section
        if [[ "$line" =~ ^\[secret\] ]]; then
            # Print previous secret if exists
            if [[ -n "$name" ]]; then
                echo -e "${BLUE}Name:${NC} $name"
                echo -e "${BLUE}Path:${NC} $path"
                echo -e "${BLUE}Description:${NC} $description"
                echo -e "${BLUE}Required by:${NC} $required_by"
                [[ -n "$op_account" ]] && echo -e "${BLUE}1Password Account:${NC} $op_account"
                [[ -n "$setup_command" ]] && echo -e "${BLUE}Setup:${NC} $setup_command"
                echo -e "${BLUE}Source:${NC} $source_name"
                echo ""
            fi
            
            # Reset for new secret
            in_secret=true
            name="" path="" description="" required_by="" op_account="" setup_command=""
            continue
        fi
        
        # Parse key=value pairs
        if $in_secret && [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            case "$key" in
                name) name="$value" ;;
                path) path="$value" ;;
                description) description="$value" ;;
                required_by) required_by="$value" ;;
                setup_command) setup_command="$value" ;;
            esac
        fi
        done < "$secrets_file"
        
        # Print last secret
        if [[ -n "$name" ]]; then
            echo -e "${BLUE}Name:${NC} $name"
            echo -e "${BLUE}Path:${NC} $path"
            echo -e "${BLUE}Description:${NC} $description"
            echo -e "${BLUE}Required by:${NC} $required_by"
            [[ -n "$op_account" ]] && echo -e "${BLUE}1Password Account:${NC} $op_account"
            [[ -n "$setup_command" ]] && echo -e "${BLUE}Setup:${NC} $setup_command"
            echo -e "${BLUE}Source:${NC} $source_name"
            echo ""
        fi
    done
    
    echo "To set up secrets, use the setup commands listed above."
    echo ""
}

validate_secrets() {
    # Check if op CLI is available
    if ! command -v op >/dev/null 2>&1; then
        echo -e "${RED}✗${NC} 1Password CLI (op) is not installed"
        echo ""
        echo "Install with Eden packages:"
        echo "  ./install.sh --packages"
        echo ""
        exit 1
    fi
    
    # Note: We don't check authentication upfront anymore
    # We'll check per-account when validating secrets
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  Validating 1Password Secrets"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    passed=0
    failed=0
    local missing_secrets=()
    
    # Process each secrets file (trunk + branches)
    for entry in "${SECRETS_FILES[@]}"; do
        IFS='|' read -r secrets_file source_name <<< "$entry"
        
        # Skip if file doesn't exist
        [[ ! -f "$secrets_file" ]] && continue
        
        # Parse secrets file (INI-style format)
        local in_secret=false
        local name="" path="" description="" required_by="" op_account="" setup_command=""
        
        while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$line" ]] && continue
        
        # Check for [secret] section
        if [[ "$line" =~ ^\[secret\] ]]; then
            # Validate previous secret if exists
            if [[ -n "$name" ]] && [[ -n "$path" ]]; then
                echo -en "Checking: ${name} ($source_name) ... "
                
                # Try to read the secret with timeout
                if timeout 30 op read "$path" >/dev/null 2>&1; then
                    echo -e "${GREEN}✓${NC}"
                    passed=$((passed + 1))
                else
                    echo -e "${RED}✗${NC}"
                    echo "  Path: $path"
                    echo "  Source: $source_name"
                    
                    # Provide specific connection instructions if op_account is set
                    if [[ -n "$op_account" ]]; then
                        echo "  1Password Account: $op_account"
                        
                        # Check if account is added
                        if op account list 2>/dev/null | grep -q "$op_account"; then
                            # Account exists, probably just not signed in/unlocked
                            echo "  → Open 1Password desktop app and unlock"
                        else
                            # Account not added yet
                            echo "  → Add account '$op_account' in 1Password desktop app"
                        fi
                    else
                        # No specific account, provide general guidance
                        echo "  → Open and unlock 1Password desktop app"
                    fi
                    
                    [[ -n "$required_by" ]] && echo "  Required by: $required_by"
                    [[ -n "$setup_command" ]] && echo "  Setup: $setup_command"
                    missing_secrets+=("$setup_command")
                    failed=$((failed + 1))
                fi
            fi
            
            # Reset for new secret
            in_secret=true
            name="" path="" description="" required_by="" op_account="" setup_command=""
            continue
        fi
        
        # Parse key=value pairs
        if $in_secret && [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            case "$key" in
                name) name="$value" ;;
                path) path="$value" ;;
                description) description="$value" ;;
                required_by) required_by="$value" ;;
                op_account) op_account="$value" ;;
                setup_command) setup_command="$value" ;;
            esac
        fi
        done < "$secrets_file"
        
        # Validate last secret
        if [[ -n "$name" ]] && [[ -n "$path" ]]; then
            echo -en "Checking: ${name} ($source_name) ... "
            
            if timeout 30 op read "$path" >/dev/null 2>&1; then
                echo -e "${GREEN}✓${NC}"
                passed=$((passed + 1))
            else
                echo -e "${RED}✗${NC}"
                echo "  Path: $path"
                echo "  Source: $source_name"
                
                # Provide specific connection instructions if op_account is set
                if [[ -n "$op_account" ]]; then
                    echo "  1Password Account: $op_account"
                    
                    # Check if account is added
                    if op account list 2>/dev/null | grep -q "$op_account"; then
                        # Account exists, probably just not signed in/unlocked
                        echo "  → Open 1Password desktop app and unlock"
                    else
                        # Account not added yet
                        echo "  → Add account '$op_account' in 1Password desktop app"
                    fi
                else
                    # No specific account, provide general guidance
                    echo "  → Open and unlock 1Password desktop app"
                fi
                
                [[ -n "$required_by" ]] && echo "  Required by: $required_by"
                [[ -n "$setup_command" ]] && echo "  Setup: $setup_command"
                missing_secrets+=("$setup_command")
                failed=$((failed + 1))
            fi
        fi
    done
    
    echo ""
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "  Results: ${GREEN}${passed} found${NC}, ${RED}${failed} missing${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    if [ $failed -gt 0 ]; then
        echo -e "${YELLOW}⚠${NC} Some secrets are missing. Use setup scripts to configure them:"
        for cmd in "${missing_secrets[@]}"; do
            [[ -n "$cmd" ]] && echo "  $cmd"
        done
        echo ""
        exit 1
    else
        echo -e "${GREEN}✓${NC} All required secrets are configured!"
        echo ""
        exit 0
    fi
}

# Command dispatcher
case "${1:-help}" in
    list)
        list_secrets
        ;;
    validate)
        validate_secrets
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}✗${NC} Unknown command: $1"
        echo ""
        show_help
        exit 1
        ;;
esac

