#!/bin/bash
# graft-bin - Symlink binaries from branches to ~/.eden/bin
# Part of Eden's pluggable grafter system
set -e

# Report covered paths for eden doctor
if [[ "${1:-}" == "--covers" ]]; then
    echo ".local/bin"
    exit 0
fi

# Detect Eden root from script location
if [[ -z "$EDEN_ROOT" ]]; then
    SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
    EDEN_ROOT="$(cd "$(dirname "$SCRIPT_PATH")/../../../../.." && pwd)"
fi

BRANCHES_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/eden/branches"

# Check if branches file exists
if [ ! -f "$BRANCHES_FILE" ]; then
    echo "  → No branches registered (skipping)"
    exit 0
fi

# Expand variables in branch path
expand_branch_path() {
    local path="$1"
    # Expand $EDEN_ROOT
    path="${path//\$EDEN_ROOT/$EDEN_ROOT}"
    # Expand tilde
    path="${path/#\~/$HOME}"
    echo "$path"
}

eden_bin="$HOME/.eden/bin"
added=0
skipped=0
conflicts=()

# Ensure ~/.eden/bin exists
mkdir -p "$eden_bin"

# Track which branch owns which script (for conflict detection)
# Uses newline-separated "name=owner" strings (bash 3.2 compatible)
script_owners=""

_get_owner() {
    echo "$script_owners" | while IFS='=' read -r k v; do
        [ "$k" = "$1" ] && echo "$v" && return
    done
}

# Read each branch repo path
while IFS= read -r branch_path || [ -n "$branch_path" ]; do
    # Skip empty lines and comments
    [[ -z "$branch_path" || "$branch_path" =~ ^[[:space:]]*# ]] && continue

    # Expand variables and tilde
    branch_path=$(expand_branch_path "$branch_path")

    if [ ! -d "$branch_path" ]; then
        continue
    fi

    # Get branch name from path
    branch_name=$(basename "$branch_path")

    # Look for .local/bin directory in the branch
    bin_dir="$branch_path/.local/bin"
    if [ -d "$bin_dir" ]; then
        for script in "$bin_dir"/*; do
            [ -e "$script" ] || continue
            [ -f "$script" ] || continue  # Skip directories

            script_name=$(basename "$script")
            target="$eden_bin/$script_name"

            # Check if script already exists and points elsewhere
            if [ -L "$target" ]; then
                current_target=$(readlink "$target")
                if [ "$current_target" != "$script" ]; then
                    existing_owner=$(_get_owner "$script_name")
                    conflicts+=("$script_name: ${existing_owner:-unknown} vs $branch_name")
                    continue
                fi
                echo "  ✓ $script_name ($branch_name) [already linked]"
                skipped=$((skipped + 1))
                script_owners="${script_owners}${script_name}=${branch_name}"$'\n'
                continue
            elif [ -e "$target" ]; then
                conflicts+=("$script_name: file exists (not a symlink)")
                continue
            fi

            # Create symlink
            ln -sf "$script" "$target"
            echo "  → $script_name ($branch_name)"
            added=$((added + 1))
            script_owners="${script_owners}${script_name}=${branch_name}"$'\n'
        done
    fi
done < "$BRANCHES_FILE"

# Report results
if [ $added -gt 0 ]; then
    echo "  → Grafted $added new binary(ies)"
fi
[ $skipped -gt 0 ] && echo "  → Skipped $skipped already grafted"

# Report conflicts
if [ ${#conflicts[@]} -gt 0 ]; then
    echo "  ⚠ Conflicts detected:"
    for conflict in "${conflicts[@]}"; do
        echo "    • $conflict"
    done
fi

if [ $added -eq 0 ] && [ $skipped -eq 0 ] && [ ${#conflicts[@]} -eq 0 ]; then
    echo "  → No binaries found in branches"
fi

exit 0

